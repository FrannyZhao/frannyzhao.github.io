{"./":{"url":"./","title":"Initial page","keywords":"","body":"Welcome to Franny's GitHub Pages. Franny's Upgrading Interested in many, master none "},"Android/Build/android.build.system.html":{"url":"Android/Build/android.build.system.html","title":"Android Build System","keywords":"","body":"[TOC] 与其他编译系统的比较 了解Android build system的为什么这样设计可以读一读 Recursive Make Considered Harmful 和 build/core/buildsystem.html 下面是一些总结： 不像linux kernel那样，有一个顶层的makefile会递归地调用子目录的makefiles。 Android build system用脚本搜索所有的文件夹，直到找到Android.mk文件，并停止继续搜索这个Android.mk文件所在的目录的子目录，除非该Android.mk文件有写include $(call all-subdir-makefiles)或者include $(LOCAL_PATH)/xxx/Android.mk之类的。 One Android.mk == One module， 一个Android.mk对应一个编译模块。 一共有多少Android.mk呢？在Android 6.0上： $ find . -name Android.mk | wc -l 2646 .o等编译中间文件和.c等源文件不在同一个目录下，所有编译生成的文件都在out目录下。 不像linux kernel那样可以配置的选项非常多，android能配置的只有：envsetup.sh, lunch, buildspec.mk。 想配置enable, disable某个模块请看下面的“编译和安装”部分。 架构 Sequence of load vendor makefiles： BoardConfig.mk: 硬件相关的定义。 再深入细节一点可以仔细看下面这个眼花缭乱的大图： 编译命令 命令 详细说明 m Makes from the top of the tree.带参数：模块名，或者不带参数：默认目标droid。对make的简单封装，m target1可以在任意目录下执行，相当于转到根目录执行make target1 mm Builds all of the modules in the current directory, but not their dependencies.不带参数，编译当前目录（如果当前目录没有Android.mk就往上查找父目录直到找到Android.mk）下的所有模块，不编译所依赖的模块。 mmm Builds all of the modules in the supplied directories, but not their dependencies.mmm ... [:module-1,module-2,...,module-M].带参数：其中，dir-1、dir-2、dir-N都是包含有Android.mk文件的目录。在最后一个目录dir-N的后面可以带一个冒号，冒号后面可以通过逗号分隔一系列的模块名称module-1、module-2和module-M，用来表示要编译前面指定的Android.mk中的哪些模块。不编译所依赖的模块。 mma Builds all of the modules in the current directory, and their dependencies.同mm但会同时编译所依赖的模块。 mmma Builds all of the modules in the supplied directories, and their dependencies.同mmm但会同时编译所依赖的模块。 文字看晕了的话记住下面这张图就好了： 总结： mma和mmma是从Jellybean4.3开始新加入的命令，比对应的mm和mmm智能多了，不需要当前目录包含Android.mk，会解决依赖问题。 但是会消耗更多的时间来检查依赖的模块是否都编译成功。 Android.mk Android.mk 文件通常以以下两行代码作为开头： LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) 这两行代码的作用是： 设置当前模块的编译路径为当前文件夹路径。 清理（可能由其他模块设置过的）编译环境中用到的变量。 这两行代码的顺序不能倒过来哦！ 这是为什么呢？请看下面的分析： 首先我们要知道$(CLEAR_VARS)的值是build/core/clear_vars.mk； 然后再要去理解my-dir函数，定义在build/core/definitions.mk里： ########################################################### ## Retrieve the directory of the current makefile ## Must be called before including any other makefile!! ########################################################### # Figure out where we are. define my-dir $(strip \\ $(eval LOCAL_MODULE_MAKEFILE := $$(lastword $$(MAKEFILE_LIST))) \\ $(if $(filter $(BUILD_SYSTEM)/% $(OUT_DIR)/%,$(LOCAL_MODULE_MAKEFILE)), \\ $(error my-dir must be called before including any other makefile.) \\ , \\ $(patsubst %/,%,$(dir $(LOCAL_MODULE_MAKEFILE))) \\ ) \\ ) endef my-dir函数通过$$(lastword $$(MAKEFILE_LIST))拿到最后读取的makefile，然后通过$(patsubst %/,%,$(dir $(LOCAL_MODULE_MAKEFILE)))得到最后读取的makefile的路径。 最后要知道gnu make 会自动将所有读取的makefile路径都会加入到MAKEFILE_LIST变量中，而且是按照读取的先后顺序添加。 那么分析开始了，在运行本makefile文件时，$(MAKEFILE_LIST)字符串中最后一个makefile肯定是最后读取的makefile，即$(lastword $(MAKEFILE_LIST))则会返回当前路径/Android.mk，my-dir函数则会得到当前路径。 如果我们在include $(CLEAR_VARS)之后，再调用my-dir函数，那么$$(lastword $$(MAKEFILE_LIST))肯定就会返回build/core/clear_vars.mk，my-dir函数得到的值就是build/core，而不是当前的路径了。 这么一来得到的LOCAL_PATH的值就是错误的值，依赖LOCAL_PATH的其他变量也就更加不可能是正确的了！所以说 ，LOCAL_PATH必须要在任何including $(CLEAR_VARS))之前定义 。 编译静态库、动态库、apk、签名版apk等模块的Android.mk要怎么写请看Android.mk写法实例。 为了方便模块的编译，Build 系统设置了很多的编译环境变量。要编译一个模块，只要在编译之前根据需要设置这些变量然后执行编译即可。它们包括： LOCAL_SRC_FILES：当前模块包含的所有源代码文件。 LOCAL_MODULE：当前模块的名称，这个名称应当是唯一的，模块间的依赖关系就是通过这个名称来引用的。 LOCAL_C_INCLUDES：C 或 C++ 语言需要的头文件的路径。 LOCAL_STATIC_LIBRARIES：当前模块在静态链接时需要的库的名称。 LOCAL_SHARED_LIBRARIES：当前模块在运行时依赖的动态库的名称。 LOCAL_CFLAGS：提供给 C/C++ 编译器的额外编译参数。 LOCAL_JAVA_LIBRARIES：当前模块依赖的 Java 共享库。 LOCAL_STATIC_JAVA_LIBRARIES：当前模块依赖的 Java 静态库。 LOCAL_PACKAGE_NAME：当前 APK 应用的名称。 LOCAL_CERTIFICATE：签署当前应用的证书名称。 LOCAL_MODULE_TAGS：当前模块所包含的标签，一个模块可以包含多个标签。标签的值可能是 debug, eng或者optional。其中optional 是默认标签。标签是提供给编译类型TARGET_BUILD_VARIANT使用的。不同的编译类型会安装包含不同标签的模块，关于编译类型的说明下面来讲。 编译和安装 首先我们要知道并不是所有编译了的模块都会安装打包进img，有的模块是只编译不安装的哦！ module 在单独mmm编译的时候，是可以安装到out中的system对应位置的，最后能够打包进系统的system.img。 但是如果整体的 make -j 编译系统，那么module就会先生成在out下的*symbols/system对应的位置，最后会不会打包进系统system.img要看module 的LOCAL_MODULE_TAGS和当前的编译的TARGET_BUILD_VARIANT没有满足下面表格中的规则。 三种编译类型TARGET_BUILD_VARIANT与安装模块的规则 名称 详细说明 eng 默认类型，该编译类型适用于开发阶段。当选择这种类型时，编译结果将：安装包含 eng, debug标签的模块;安装所有没有标签的非 APK 模块;安装所有PRODUCT_PACKAGES宏中指定的 APK 模块;编译出的系统具有 root 访问权限;ro.secure=0;ro.debuggable=1;ro.kernel.android.checkjni=1;adb enabled userdebug 该编译类型适合用于 debug 阶段。当选择这种类型时，编译结果将：安装所有带有 debug标签的模块;安装所有没有标签的非 APK 模块;安装所有PRODUCT_PACKAGES宏中指定的 APK 模块编译出的系统具有 root 访问权限;ro.secure=1;ro.debuggable=1;adb enabled user 该编译类型适合用于最终发布阶段。当选择这种类型时，编译结果将：安装所有没有标签的非 APK 模块;忽略APK 模块的标签，安装哪些模块只依赖PRODUCT_PACKAGES宏;编译出的系统不具有 root 访问权限;ro.secure=1;ro.debuggable=0;关闭log, console, adb, 编译出odex odex的作用：系统制作会把.odex 和 apk 一起放到system/app 下，由系统来调度使用，如果想盗版apk，单独copy出去.apk是不能用的，这样可以起到一定程度上的保护作用！ 表格里的文字看晕了的话记住下面这张图就好了： 总结： 这里可以看到对module的安装控制级别最高的是 PRODUCT_PACKAGES 这个变量。 不满足的规则的module只会被编译，并不会被install 的。 如果需要安装打包进system.img则可以按照上面表格中的规则，修改module的 LOCAL_MODULE_TAGS 或者在 PRODUCT_PACKAGES 中添加 module。 比如： LOCAL_MODULE_TAGS的默认值是optional，则该module会被编译但不会install。如果希望install的话可以： PRODUCT_PACKAGES += 该module名称 修改LOCAL_MODULE_TAGS := 对应的TARGET_BUILD_VARIANT(eng/debug) 常见模块名称 暂时就写这么多啦，以后有需要再补充~ 欢迎指导和提意见 Written with StackEdit. "},"CodeManagement/git.useful.skills.html":{"url":"CodeManagement/git.useful.skills.html","title":"Git useful skills","keywords":"","body":"[TOC] 为什么用git+gerrit+jenkins三剑客做代码版本控制 烦恼： 经常没有一个好的基础版本来发布和开发，一更新代码发现又跑不起来； 辛苦改好的代码进不去版本库； 不是我的bug却要我来花时间; 开发团队人越多，集成越困难…… 好处： 版本历史有迹可查（git）； 提交前代码检查，坏代码不会污染代码库（gerrit&jenkins）； 快速定位问题； 方便管理多项目； 方便团队合作…… git+gerrit+jenkins三剑客： 灵活，快速，强大，好用。 git各种命令与状态： 想详细了解更多git技能推荐阅读：Git Community Book 中文版 本文挑了最最实用、最最常用的技能，方便大家快速掌握，提高工作效率。 在理解下面的技能前，希望大家先在脑海中形象滴理解下git branch和git commit: 把branch理解成一条流水线，把commit理解成乐高积木。 branch这条流水线是由一个一个commit积木组成的。 更新代码 不要用git pull, 改用git fetch + git rebase 因为git pull会做git merge产生讨厌的merge commit。 merge commit是什么？ git中两个branch合并的时候，需要做个标记，这是我们合并的点，就像两根绳子打个结： 这个结就是git merge时生成的merge commit。 merge commit为啥就讨厌了？ 如果是重要的branch合并，我们会需要个merge commit作为见证。就像结婚说誓词时需要个证婚人一样。 但是你平时说话就不需要见证了，不然太累了。 因为你的本地branch根本不重要，跟主线master合并的时候不需要留下见证。 主线只要你的commit并不想要整个branch。 解决办法： git fetch origin git rebase origin/master git rebase做的动作就是把你的commit挪到主线的最顶端。 rebase过程中出现冲突怎么办？ git status 看下哪个文件冲突了？（假设是src/java/a.java有冲突） 打开这个文件，解决冲突 git add src/java/a.java git rebase --continue 提交 提交前自检： 过一遍自己刚才改了什么 git status git diff git命令都可以加路径来指定文件或者目录，这几个命令也不例外。 比如： git status . 查看当前目录下修改的文件。 git diff src/java/franny.java 查看franny.java文件的具体修改。 提交 git commit git push origin HEAD:refs/for/master git commit . 提交当前目录下修改的文件； git commit src/java/a.java src/java/b.java 只提交a.java, b.java这两个文件。 refs/for 表示提交到gerrit上，走代码review流程，由有权限的人review过才给你合进代码库。 与其对应的是refs/heads和refs/tags直接提交进代码库，普通群众是没有这个权限的就不说了。 还原文件 常用场景： 哎呀，我修改了几十个文件还分散个各种不同目录下，其中有一个文件（假设叫a.java）不需要提交咋办，用git commit file1 file2 file3 ... 太麻烦。 解决办法： 那么就先把a.java还原成未修改的状态： git checkout src/java/a.java 然后git commit -a 一次性提交全部文件。 合并多个提交 常用场景： 哎呀，我的修改提交了2个commit，我想把它们合并成一个commit然后push。 $ git log commit bbb6ca1ddca3b7b59f299c5b9e6bb0c8dc965793 Author: Zhao Fengyi Date: Tue Aug 23 20:10:49 2016 +0800 this is my 3rd commit commit 72fa1768fe5db08323394fe1f4a3fb8d71b7c712 Author: Zhao Fengyi Date: Tue Aug 23 20:10:09 2016 +0800 this is my 2nd commit commit 87ee65f7ff23afacbbe98c62965b243557e3a3e0 Author: Zhao Fengyi Date: Tue Aug 23 20:09:55 2016 +0800 this is my 1st commit 即： 我想把后面的2个提交合并成一个提交。 解决办法有3种： 第一种办法 git reset 把后面2个提交的文件变成未提交状态 git add . ; git commit -am \"blabla\" 把所有为提交的文件一次性提交 具体执行过程： $ git status On branch master nothing to commit, working directory clean $ git reset 87ee65f7ff23afacbbe98c62965b243557e3a3e0 ``` $ git status On branch master Untracked files: (use \"git add ...\" to include in what will be committed) b.java c.java nothing added to commit but untracked files present (use \"git add\" to track) ``` $ git add . ; git commit -am \"merge 2 commits together\" [master 5115542] merge 2 commits together 2 files changed, 24 insertions(+) create mode 100644 src/java/b.java create mode 100644 src/java/c.java $ git log commit 5115542312503fc0422d48e531d12ee506384cd4 Author: Zhao Fengyi Date: Tue Aug 23 20:16:22 2016 +0800 merge 2 commits together commit 87ee65f7ff23afacbbe98c62965b243557e3a3e0 Author: Zhao Fengyi Date: Tue Aug 23 20:09:55 2016 +0800 this is my 1st commit 第二种办法git checkout git merge --squash git commit -a 具体执行过程： ``` $ git checkout 87ee65f7ff23afacbbe98c62965b243557e3a3e0 Note: checking out '87ee65f7ff23afacbbe98c62965b243557e3a3e0'. You are in 'detached HEAD' state. You can look around, make experimental changes and commit them, and you can discard any commits you make in this state without impacting any branches by performing another checkout. If you want to create a new branch to retain commits you create, you may do so (now or later) by using -b with the checkout command again. Example: git checkout -b new_branch_name HEAD is now at 87ee65f... this is my first commit ``` $ git merge 72fa1768fe5db08323394fe1f4a3fb8d71b7c712 bbb6ca1ddca3b7b59f299c5b9e6bb0c8dc965793 --squash Updating 87ee65f..bbb6ca1 Fast-forward Squash commit -- not updating HEAD src/java/b.java | 12 ++++++++++++ src/java/c.java | 12 ++++++++++++ 2 files changed, 24 insertions(+) create mode 100644 src/java/b.java create mode 100644 src/java/c.java $ git status HEAD detached at 87ee65f Changes to be committed: (use \"git reset HEAD ...\" to unstage) new file: b.java new file: c.java $ git commit -a [detached HEAD 0212114] Squashed commit of the following: 2 files changed, 24 insertions(+) create mode 100644 src/java/b.java create mode 100644 src/java/c.java $ git log commit 021211462df14dae5084842b85c0122222dcc453 Author: Zhao Fengyi Date: Tue Aug 23 20:26:32 2016 +0800 Squashed commit of the following: commit bbb6ca1ddca3b7b59f299c5b9e6bb0c8dc965793 Author: Zhao Fengyi Date: Tue Aug 23 20:10:49 2016 +0800 this is my 3rd commit commit 72fa1768fe5db08323394fe1f4a3fb8d71b7c712 Author: Zhao Fengyi Date: Tue Aug 23 20:10:09 2016 +0800 this is my 2nd commit commit 87ee65f7ff23afacbbe98c62965b243557e3a3e0 Author: Zhao Fengyi Date: Tue Aug 23 20:09:55 2016 +0800 this is my 1st commit 第三种办法（防患于未然，推荐）： ``` 为某个问题修改了一些文件 git commit -am \"blabla\" 为同样的问题又做了些修改 git commit -a --amend ---------- 找不同版本的区别 -- **常用场景**： 这个bug上个版本还没有，这个版本怎么就出现了呢？我得看看上个版本和这个版本之间都改了什么。 **解决办法**： - 粗糙版命令（适用于版本之间提交不多，git log .. -- 具体执行过程： src/main/java/com/xxx/yyy/ui/activity$ git log origin/v7.7..origin/v7.8 -- . commit aaaaaaaaaaaaaaaaaaaaaaaaaaaa Author: Y y@q.com Date: Tue Aug 23 18:12:33 2016 +0800 [需求开发]...... Change-Id: ...... commit bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb Author: l l@q.com Date: Tue Aug 23 15:26:21 2016 +0800 【bug fixed】...... commit cccccccccccccccccccccccccccccccccccccc Author: G g@q.com Date: Tue Aug 23 16:32:20 2016 +0800 需求-从第三方跳入...... Change-Id: ...... commit ddddddddddddddddddddddddddddddddddd Author: S s@q.com Date: Tue Aug 23 10:12:26 2016 +0800 [功能优化]去掉无用的xxx.java Change-Id: ...... 缺点是太多了，排版不紧凑，找个信息要半天。 - 精致版命令（紧凑，不费眼） git log .. --color --graph --pretty=format:'%Cred%h%Creset -%s %Cgreen(%cr) %C(bold blue)%Creset' -- 具体执行过程： src/main/java/com/xxx/yyy/ui/activity$ git log origin/v7.7..origin/v7.8 --color --graph --pretty=format:'%Cred%h%Creset -%s %Cgreen(%cr) %C(bold blue)%Creset' -- . a30af7c -[需求开发] ... (16 hours ago) cacb3f5 -【bug fixed】... (18 hours ago) b332d79 -需求-从第三方跳入... (18 hours ago) 0385105 -[功能优化] 去掉无用的 xxx.java (18 hours ago) ``` 这锅该谁背 常用场景： 找到了，就是这行代码改出来的问题，看看谁改的。 解决办法： git blame -L Android Studio有提供同样的操作： 高级一点的需求： git blame 只能看到谁加了这行，如果知道有些代码被删了，想看看谁删了怎么办呢？ 解决办法： git log -p -- 在打印里搜索被删除的行。 具体执行过程： src/main/java/com/xxx/yyy/ui/view/message$ git log -p -- LLLView.java 搜索 xxxManager\\.getyyy\\(\\)\\.play 方便的配置 作为一个熟悉git的人，我平时提交代码只需要1行命令就搞定了 git f && git rh && git rbm && git sa && git pm 要想操作这么便捷，做一些前期配置就可以一劳永逸了。 缩写alias git 这么多命令，敲起来又长又麻烦，一不小心敲错了就更烦了。 打开 ~/.gitconfig， 把下面的缩写添加进去 [alias] co = checkout cp = cherry-pick br = branch st = status l1 = log -1 pm = push origin HEAD:refs/for/master ap = apply cm = commit rbm = rebase origin/master f = fetch origin rh = reset --hard sa = stash apply --0 各种平台换行符不一致，git提交时统一转换： git config --global core.autocrlf true git config --global core.autocrlf true 暂存不用提交的修改 比如gradle project sync耗时太久，我改成用本地的服务器： distributionUrl=http\\://10.x.y.z:8080/download/gradle-2.12-all.zip 这个修改又不需要提交，只是本地开发时需要。 我们一般把不需要提交的修改用git stash暂存在本地； 需要提交的修改git commit提交到本地。 这样要提交的修改和不需要提交的修改就分开了，不会出现每次提交代码要自己再分离一次。 配置好了，git commit了需要提交的代码后，可以一行命令搞定推送到gerrit了。 git f && git rh && git rbm && git sa && git pm 命令 详细说明 git f git fetch origin 从git服务器获取最新代码状态 git rh git reset --hard 清空本地不需要提交的代码 git rbm git rebase origin/master 把自己的commit合并进master git sa git stash apply --0 恢复暂存的修改 git pm git push origin HEAD:refs/for/master 推到gerrit 然后继续开发下一个commit吧～ 其他 有时候会遇到一些棘手的问题。 比如：之前git commit了一个提交，然后做了一堆git checkout或者别的操作导致找不到这个commit了。 vi .git/logs/HEAD 或者 git reflog 都可以查看你的操作历史。曾经从哪里checkout到哪里，commit了什么，rebase到哪里了...都一目了然。 比如：之前解决了一次冲突，然后发现不应该这么解决，想换种办法解决。 但是git会自动记住你之前的解决办法，自动帮你解决了，你根本没有插手的机会。 rm -rf .git/rr-cache/* 让git忘记我之前的解决办法，这样就给了我插手的机会，重新解决一次。 暂时就写这么多啦，以后有需要再补充~ 欢迎指导和提意见 Written with StackEdit. "},"Android/JNI/jni.html":{"url":"Android/JNI/jni.html","title":"JNI","keywords":"","body":"[TOC] JNI: Java Native Interface 目的：java & c/c++可以互相调用对方的函数 对java层屏蔽不同操作系统的差异 native已经实现的功能可以直接用，避免重复造轮子 native实现部分的运行效率和速度快 Java(MediaScanner) JNI(libmedia_jni.so) Native(libmedia.so) public class MediaScanner { static { System.loadLibrary(\"media_jni\"); // 根据不同平台扩展，linux下扩展为libmedia_jni.so, windows下扩展为media_jni.dll native_init(); } ... } java native关键字 该方法的实现由非java语言实现，比如C。这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在C＋＋中，你可以用extern \"C\"告知C＋＋编译器去调用一个C的函数; 标识符native不能与abstract连用; 如果一个含有native方法的类被继承，子类会继承这个本地方法并且可以用java语言重写这个方法（这个似乎看起来有些奇怪），同样的如果一个本地方法被final标识，它被继承后不能被重写。 JNI HelloWorld实例: 静态注册 参考https://blog.csdn.net/xyang81/article/details/41777471自己实现JNI Helloworldhttps://gist.github.com/FrannyZhao/3fb01202e598495033744a40bc841d2e 静态注册是根据函数名来建立Java函数和JNI函数的对应关系的（.对应 _ , _ 对应 _1）. 弊端： 需要编译所有包含native方法的Java类，每个.class都需要用javah生成一个头文件； javah生成的JNI函数名特别长，用起来不太方便； 初次调用native函数时需要通过函数名字搜索对应的JNI层函数来建立关联关系，会影响效率。 用动态注册来解决上面的弊端： JVM加载native方法的过程 Created with Raphaël 2.1.4JVM加载包含native方法的类该类的字节码会被加载到内存，在这个被加载的字节码的入口维持着一个该类所有方法描述符的list，这些方法描述符包含这样一些信息：方法代码存于何处，它有哪些参数，方法的描述符（public之类）等等如果一个方法描述符内有native，这个描述符块将有一个指向该方法的实现的指针当native方法被调用之前，这些DLL,SO才会被加载，这是通过调用java.system.loadLibrary()实现的 观察android_media_MediaScanner.cpp中两个native方法 native_init() static void android_media_MediaScanner_native_init(JNIEnv *env) { ALOGV(\"native_init\"); jclass clazz = env->FindClass(kClassMediaScanner); if (clazz == NULL) { return; } fields.context = env->GetFieldID(clazz, \"mNativeContext\", \"J\"); if (fields.context == NULL) { return; } } private native void processFile(String path, String mimeType, MediaScannerClient client); static void android_media_MediaScanner_processFile( JNIEnv *env, jobject thiz, jstring path, jstring mimeType, jobject client) { ALOGV(\"processFile\"); // Lock already hold by processDirectory MediaScanner *mp = getNativeScanner_l(env, thiz); if (mp == NULL) { jniThrowException(env, kRunTimeException, \"No scanner available\"); return; } if (path == NULL) { jniThrowException(env, kIllegalArgumentException, NULL); return; } const char *pathStr = env->GetStringUTFChars(path, NULL); if (pathStr == NULL) { // Out of memory return; } const char *mimeTypeStr = (mimeType ? env->GetStringUTFChars(mimeType, NULL) : NULL); if (mimeType && mimeTypeStr == NULL) { // Out of memory // ReleaseStringUTFChars can be called with an exception pending. env->ReleaseStringUTFChars(path, pathStr); return; } MyMediaScannerClient myClient(env, client); MediaScanResult result = mp->processFile(pathStr, mimeTypeStr, myClient); if (result == MEDIA_SCAN_RESULT_ERROR) { ALOGE(\"An error occurred while scanning file '%s'.\", pathStr); } env->ReleaseStringUTFChars(path, pathStr); if (mimeType) { env->ReleaseStringUTFChars(mimeType, mimeTypeStr); } } JNIEnv类型实际上代表了Java环境，通过这个JNIEnv* 指针，就可以对Java端的代码进行操作。例如，创建Java类中的对象，调用Java对象的方法，获取Java对象中的属性等等。JNIEnv的指针会被JNI传入到本地方法的实现函数中来对Java端的代码进行操作。 JNIEnv类中有很多函数可以用： NewObject:创建Java类中的对象 NewString:创建Java类中的String对象 NewArray:创建类型为Type的数组对象 GetField:获取类型为Type的字段 SetField:设置类型为Type的字段的值 GetStaticField:获取类型为Type的static的字段 SetStaticField:设置类型为Type的static的字段的值 CallMethod:调用返回类型为Type的方法 CallStaticMethod:调用返回值类型为Type的static方法 等许多的函数，具体的可以查看jni.h文件中的函数名称。 native函数的对应关系： static const JNINativeMethod gMethods[] = { ... { \"processFile\", \"(Ljava/lang/String;Ljava/lang/String;Landroid/media/MediaScannerClient;)V\", (void *)android_media_MediaScanner_processFile }, ... { \"native_init\", \"()V\", (void *)android_media_MediaScanner_native_init }, ... }; "},"Algorithms/Array/two.sum.html":{"url":"Algorithms/Array/two.sum.html","title":"Two Sum","keywords":"","body":"[TOC] Description: Two Sum Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. 给一个数组，寻找其中的2个数加起来等于目标值 Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. Solutions Approach 1: Brute Force The brute force approach is simple. Loop through each element x and find if there is another value that equals to target−x. 简单粗暴遍历，针对所有的元素，寻找target-x的元素。时间复杂度O(n^2) public int[] twoSum(int[] nums, int target) { for (int i = 0; i Complexity Analysis Time complexity : O(n^2). For each element, we try to find its complement by looping through the rest of array which takes O(n) time. Therefore, the time complexity is O(n^2). Space complexity : O(1). Approach 2: Two-pass Hash Table To improve our run time complexity, we need a more efficient way to check if the complement exists in the array. If the complement exists, we need to look up its index. What is the best way to maintain a mapping of each element in the array to its index? A hash table. We reduce the look up time from O(n) to O(1) by trading space for speed. A hash table is built exactly for this purpose, it supports fast look up in near constant time. I say \"near\" because if a collision occurred, a look up could degenerate to O(n) time. But look up in hash table should be amortized O(1) time as long as the hash function was chosen carefully. A simple implementation uses two iterations. In the first iteration, we add each element's value and its index to the table. Then, in the second iteration we check if each element's complement (target−nums[i]) exists in the table. Beware that the complement must not be nums[i] itself! 利用hashmap提高查询的速度，把该数组放入(nums[i],i)的hashmap中，遍历所有元素，用containsKey寻找(target-x)的元素。一共遍历了两遍数组，时间复杂度：O(n)+O(n)=O(n) public int[] twoSum(int[] nums, int target) { Map map = new HashMap<>(); for (int i = 0; i Complexity Analysis: Time complexity : O(n). We traverse the list containing nnelements exactly twice. Since the hash table reduces the look up time to O(1), the time complexity is O(n). Space complexity : O(n). The extra space required depends on the number of items stored in the hash table, which stores exactly n elements. Approach 3: One-pass Hash Table It turns out we can do it in one-pass. While we iterate and inserting elements into the table, we also look back to check if current element's complement already exists in the table. If it exists, we have found a solution and return immediately. 其实可以只遍历一次数组，把元素放入hashmap中，同时检查有没有(target-x)元素。时间复杂度O(n) public int[] twoSum(int[] nums, int target) { Map map = new HashMap<>(); for (int i = 0; i Complexity Analysis: Time complexity : O(n). We traverse the list containing nnelements only once. Each look up in the table costs only O(1) time. Space complexity : O(n). The extra space required depends on the number of items stored in the hash table, which stores at most n elements. "},"Algorithms/Array/median.of.two.sorted.arrays.html":{"url":"Algorithms/Array/median.of.two.sorted.arrays.html","title":"Median of Two Sorted Arrays","keywords":"","body":"[TOC] Description: Median of Two Sorted Arrays There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. 两个升序排好的数组，大小分别为m和n，找到它们合在一起的中位数。要求时间复杂度O(log(m+n)) Example 1: nums1 = [1, 3] nums2 = [2] The median is 2.0 Example 2: nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 Solutions "}}