{"./":{"url":"./","title":"Home page","keywords":"","body":"Welcome to Franny's GitHub Pages. Franny's Upgrading http://frannyzhao.github.io/ Interested in many, master none "},"Algorithms/Array/median.of.two.sorted.arrays.html":{"url":"Algorithms/Array/median.of.two.sorted.arrays.html","title":"Median Of Two Sorted Arrays","keywords":"","body":"[TOC] Description: Median of Two Sorted Arrays There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. 两个升序排好的数组，大小分别为m和n，找到它们合在一起的中位数。要求时间复杂度O(log(m+n)) Example 1: nums1 = [1, 3] nums2 = [2] The median is 2.0 Example 2: nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 Solutions "},"Algorithms/Array/two.sum.html":{"url":"Algorithms/Array/two.sum.html","title":"Two Sum","keywords":"","body":"[TOC] Description: Two Sum Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. 给一个数组，寻找其中的2个数加起来等于目标值 Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. Solutions Approach 1: Brute Force The brute force approach is simple. Loop through each element x and find if there is another value that equals to target−x. 简单粗暴遍历，针对所有的元素，寻找target-x的元素。时间复杂度O(n^2) public int[] twoSum(int[] nums, int target) { for (int i = 0; i Complexity Analysis Time complexity : O(n^2). For each element, we try to find its complement by looping through the rest of array which takes O(n) time. Therefore, the time complexity is O(n^2). Space complexity : O(1). Approach 2: Two-pass Hash Table To improve our run time complexity, we need a more efficient way to check if the complement exists in the array. If the complement exists, we need to look up its index. What is the best way to maintain a mapping of each element in the array to its index? A hash table. We reduce the look up time from O(n) to O(1) by trading space for speed. A hash table is built exactly for this purpose, it supports fast look up in near constant time. I say \"near\" because if a collision occurred, a look up could degenerate to O(n) time. But look up in hash table should be amortized O(1) time as long as the hash function was chosen carefully. A simple implementation uses two iterations. In the first iteration, we add each element's value and its index to the table. Then, in the second iteration we check if each element's complement (target−nums[i]) exists in the table. Beware that the complement must not be nums[i] itself! 利用hashmap提高查询的速度，把该数组放入(nums[i],i)的hashmap中，遍历所有元素，用containsKey寻找(target-x)的元素。一共遍历了两遍数组，时间复杂度：O(n)+O(n)=O(n) public int[] twoSum(int[] nums, int target) { Map map = new HashMap<>(); for (int i = 0; i Complexity Analysis: Time complexity : O(n). We traverse the list containing nnelements exactly twice. Since the hash table reduces the look up time to O(1), the time complexity is O(n). Space complexity : O(n). The extra space required depends on the number of items stored in the hash table, which stores exactly n elements. Approach 3: One-pass Hash Table It turns out we can do it in one-pass. While we iterate and inserting elements into the table, we also look back to check if current element's complement already exists in the table. If it exists, we have found a solution and return immediately. 其实可以只遍历一次数组，把元素放入hashmap中，同时检查有没有(target-x)元素。时间复杂度O(n) public int[] twoSum(int[] nums, int target) { Map map = new HashMap<>(); for (int i = 0; i Complexity Analysis: Time complexity : O(n). We traverse the list containing nnelements only once. Each look up in the table costs only O(1) time. Space complexity : O(n). The extra space required depends on the number of items stored in the hash table, which stores at most n elements. "},"Algorithms/Sort/ten.classic.sort.html":{"url":"Algorithms/Sort/ten.classic.sort.html","title":"Ten Classic Sort","keywords":"","body":"[TOC] Ten classic sort algorithms Summary 参考： https://mp.weixin.qq.com/s/vn3KiV-ez79FmbZ36SX9lg https://mp.weixin.qq.com/s/Qf416rfT4pwURpW3aDHuCg 时间复杂度 | 时间复杂度 | 排序 | | ------------------------------ | ------------------------------------------ | | O(n^2) | 各类简单排序：直接插入，直接选择，冒泡排序 | | O(nlgn) | 快速排序，堆排序，归并排序 | | O(n1+§)，§是介于0和1之间的常数 | 希尔排序 | | O(n) | 基数排序，桶排序，计数排序 | 稳定性 稳定性 排序 稳定 冒泡排序，插入排序，归并排序，基数排序 不稳定 选择排序，快速排序，希尔排序，堆排序 Bubble sort import java.util.Arrays; public class BubbleSort { public int[] sort(int[] srcArr) { int[] arr = Arrays.copyOf(srcArr, srcArr.length); boolean hasChanged; for (int i = arr.length - 1; i > 0; i --) { hasChanged = false; for (int j = 0; j arr[j + 1]) { int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; hasChanged = true; } } if (!hasChanged) { break; } } return arr; } } 重点 for (int i = arr.length - 1; i > 0; i --) { for (int j = 0; j if (arr[j] > arr[j + 1] ) { 时间： $$ O(n^2) $$ 空间：O(1) 稳定性：稳定 Selection sort import java.util.Arrays; public class SelectionSort { public int[] sort(int[] srcArr) { int[] arr = Arrays.copyOf(srcArr, srcArr.length); int min, tmp; for (int i = 0; i 重点 for (int i = 0; i for (int j = i + 1; j 时间： $$ O(n^2) $$ 空间：O(1) 稳定性： 不稳定 选择排序不是稳定的排序算法，因为： 序列 5 8 5 2 9，第一遍选择第一个5会和2交换，那么原序列中两个5的相对前后顺序就被破坏了。 Insert sort import java.util.Arrays; public class InsertSort { public int[] sort(int[] srcArr) { int[] arr = Arrays.copyOf(srcArr, srcArr.length); int tmp; for (int i = 1; i 0 && tmp 重点 ​ for (int i = 1; i 0 && tmp 时间： $$ O(n^2) $$ 空间：O(1) 稳定性： 稳定 Shell sort import java.util.Arrays; public class ShellSort { public int[] sort(int[] srcArr) { int[] arr = Arrays.copyOf(srcArr, srcArr.length); int gap = 1; while (gap 0) { for (int i = gap; i = gap && tmp 重点 ​ while (gap > 0) { ​ for (int i = gap; i = gap && tmp 时间： $$ O(N^{1.289}) 到 O(2.5NlgN)之间，精确的模型还没找到 $$ 空间：O(1) 稳定性： 不稳定 Merge sort import java.util.Arrays; public class MergeSort { public int[] sort(int[] srcArr) { int[] arr = Arrays.copyOf(srcArr, srcArr.length); if (arr.length 重点 ​ int middle = (int) Math.floor(arr.length / 2); ​ int[] left = Arrays.copyOfRange(arr, 0, middle); ​ int[] right = Arrays.copyOfRange(arr, middle, arr.length); 时间： $$ O(NlgN) $$ 空间：O() 稳定性： 稳定 Quick sort import java.util.Arrays; public class QuickSort { public int[] sort(int[] srcArr) { int[] arr = Arrays.copyOf(srcArr, srcArr.length); return quickSort(arr, 0, arr.length - 1); } public int[] quickSort(int[] arr, int start, int end) { if (start = pivotValue && left 重点 双边扫描：先从右往左，最后对调left和start 时间： $$ O(NlgN) $$ 空间： 首先就地快速排序使用的空间是O(1)的，也就是个常数级； 而真正消耗空间的就是递归调用了，因为每次递归就要保持一些数据； 最优的情况下空间复杂度为：O(logn)，每一次都平分数组的情况 最差的情况下空间复杂度为：O(n)，退化为冒泡排序的情况, 优化点是怎么取哨兵元素才能不会让这个算法退化到冒泡排序 稳定性： 不稳定 Heap sort package sort; import java.util.Arrays; public class HeapSort { public int[] sort(int[] srcArr) { int[] arr = Arrays.copyOf(srcArr, srcArr.length); for (int i = (int) Math.floor(arr.length / 2); i >= 0; i--) { heapify(arr, i, arr.length); } int length = arr.length; for (int i = length - 1; i > 0; i--) { //将堆顶元素与末位元素调换 int tmp = arr[0]; arr[0] = arr[i]; arr[i] = tmp; length--; //数组长度-1 隐藏堆尾元素 heapify(arr, 0, length); } return arr; } private void heapify(int[] arr, int index, int length) { int leftChild = 2 * index + 1;//左子节点下标 int rightChild = 2 * index + 2;//右子节点下标 int present = index;//要调整的节点下标 //调整左边 if (leftChild arr[present]) { present = leftChild; } //调整右边 if (rightChild arr[present]) { present = rightChild; } //如果下标不相等 证明调换过了 if (present != index) { //交换值 int temp = arr[index]; arr[index] = arr[present]; arr[present] = temp; //继续调整 heapify(arr, present, length); } } } 重点 ​ int leftChild = 2 index + 1;//左子节点下标 ​ int rightChild = 2 index + 2;//右子节点下标 ​ int present = index;//要调整的节点下标 ​ //调整左边 ​ if (leftChild arr[present]) { ​ present = leftChild; ​ } ​ //调整右边 ​ if (rightChild arr[present]) { ​ present = rightChild; ​ } ​ //如果下标不相等 证明调换过了 ​ if (present != index) { ​ //交换值 ​ int temp = arr[index]; ​ arr[index] = arr[present]; ​ arr[present] = temp; ​ //继续调整 ​ heapify(arr, present, length); ​ } 时间： $$ O(NlgN) $$ 空间：O(1) 稳定性： 不稳定 Counting sort package sort; import java.util.Arrays; /** * 计数排序只适用于正整数, 并且取值范围相差不大的数组排序使用，它的排序的速度是非常可观的。 * @author zhaofengyi * */ public class CoutingSort { public int[] sort(int[] srcArr) { int[] arr = Arrays.copyOf(srcArr, srcArr.length); //找到最大值和最小值 int maxValue = arr[0]; int minValue = arr[0]; for (int value : arr) { if (maxValue value) { minValue = value; } } //创建计数数组 int[] bucket = new int[maxValue - minValue + 1]; for (int value : arr) { bucket[value - minValue]++; } int sortedIndex = 0; for (int j = 0; j 0) { arr[sortedIndex++] = j + minValue; bucket[j]--; } } return arr; } } 重点 int[] bucket = new int[maxValue - minValue + 1]; for (int value : arr) { bucket[value - minValue]++; } while (bucket[j] > 0) { arr[sortedIndex++] = j + minValue; bucket[j]--; } 时间： $$ O(N+k) $$ 空间：O() 稳定性： 稳定 Bucket sort package sort; import java.util.Arrays; public class BucketSort { public int[] sort(int[] srcArr) { int[] arr = Arrays.copyOf(srcArr, srcArr.length); int bucketSize = 5; if (arr.length == 0) { return arr; } int minValue = arr[0]; int maxValue = arr[0]; for (int value : arr) { if (value maxValue) { maxValue = value; } } int bucketCount = (int) Math.floor((maxValue - minValue) / bucketSize) + 1; /* 用ArrayList实现桶 ArrayList> bucketList = new ArrayList<>(); for (int i = 0; i ()); } // 利用映射函数将数据分配到各个桶中 for (int i = 0; i 0 && arr[i] bucket : bucketList) { if (bucket.size() 0 && arr[i] 重点 在额外空间充足的情况下，尽量增大桶的数量，极限情况下每个桶只有一个数据时，或者是每只桶只装一个值时，完全避开了桶内排序的操作，桶排序的最好时间复杂度就能够达到 O(n)。 时间： $$ O(N+k) $$ 空间：O(N+k) 稳定性： 稳定 Radix sort package sort; import java.util.Arrays; public class RadixSort { public int[] sort(int[] srcArr) { int[] arr = Arrays.copyOf(srcArr, srcArr.length); // 找到最大值 int maxValue = arr[0]; for (int value : arr) { if (value > maxValue) { maxValue = value; } } // 找到最大位数 int numLength = 0; do { numLength++; maxValue /= 10; } while (maxValue != 0); // 开始排序 int mod = 10; int dev = 1; for (int i = 0; i 重点 int[][] counter = new int[mod * 2][0]; for (int j = 0; j 时间： $$ O(Nk) $$ k是最大值的位数* 空间：O(N+k) 稳定性： 稳定 "},"Android/Build/android.build.system.html":{"url":"Android/Build/android.build.system.html","title":"Android Build System","keywords":"","body":"[TOC] 与其他编译系统的比较 了解Android build system的为什么这样设计可以读一读 Recursive Make Considered Harmful 和 build/core/buildsystem.html 下面是一些总结： 不像linux kernel那样，有一个顶层的makefile会递归地调用子目录的makefiles。 Android build system用脚本搜索所有的文件夹，直到找到Android.mk文件，并停止继续搜索这个Android.mk文件所在的目录的子目录，除非该Android.mk文件有写include $(call all-subdir-makefiles)或者include $(LOCAL_PATH)/xxx/Android.mk之类的。 One Android.mk == One module， 一个Android.mk对应一个编译模块。 一共有多少Android.mk呢？在Android 6.0上： $ find . -name Android.mk | wc -l 2646 .o等编译中间文件和.c等源文件不在同一个目录下，所有编译生成的文件都在out目录下。 不像linux kernel那样可以配置的选项非常多，android能配置的只有：envsetup.sh, lunch, buildspec.mk。 想配置enable, disable某个模块请看下面的“编译和安装”部分。 架构 Sequence of load vendor makefiles： BoardConfig.mk: 硬件相关的定义。 再深入细节一点可以仔细看下面这个眼花缭乱的大图： 编译命令 命令 详细说明 m Makes from the top of the tree.带参数：模块名，或者不带参数：默认目标droid。对make的简单封装，m target1可以在任意目录下执行，相当于转到根目录执行make target1 mm Builds all of the modules in the current directory, but not their dependencies.不带参数，编译当前目录（如果当前目录没有Android.mk就往上查找父目录直到找到Android.mk）下的所有模块，不编译所依赖的模块。 mmm Builds all of the modules in the supplied directories, but not their dependencies.mmm ... [:module-1,module-2,...,module-M].带参数：其中，dir-1、dir-2、dir-N都是包含有Android.mk文件的目录。在最后一个目录dir-N的后面可以带一个冒号，冒号后面可以通过逗号分隔一系列的模块名称module-1、module-2和module-M，用来表示要编译前面指定的Android.mk中的哪些模块。不编译所依赖的模块。 mma Builds all of the modules in the current directory, and their dependencies.同mm但会同时编译所依赖的模块。 mmma Builds all of the modules in the supplied directories, and their dependencies.同mmm但会同时编译所依赖的模块。 文字看晕了的话记住下面这张图就好了： 总结： mma和mmma是从Jellybean4.3开始新加入的命令，比对应的mm和mmm智能多了，不需要当前目录包含Android.mk，会解决依赖问题。 但是会消耗更多的时间来检查依赖的模块是否都编译成功。 Android.mk Android.mk 文件通常以以下两行代码作为开头： LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) 这两行代码的作用是： 设置当前模块的编译路径为当前文件夹路径。 清理（可能由其他模块设置过的）编译环境中用到的变量。 这两行代码的顺序不能倒过来哦！ 这是为什么呢？请看下面的分析： 首先我们要知道$(CLEAR_VARS)的值是build/core/clear_vars.mk； 然后再要去理解my-dir函数，定义在build/core/definitions.mk里： ########################################################### ## Retrieve the directory of the current makefile ## Must be called before including any other makefile!! ########################################################### # Figure out where we are. define my-dir $(strip \\ $(eval LOCAL_MODULE_MAKEFILE := $$(lastword $$(MAKEFILE_LIST))) \\ $(if $(filter $(BUILD_SYSTEM)/% $(OUT_DIR)/%,$(LOCAL_MODULE_MAKEFILE)), \\ $(error my-dir must be called before including any other makefile.) \\ , \\ $(patsubst %/,%,$(dir $(LOCAL_MODULE_MAKEFILE))) \\ ) \\ ) endef my-dir函数通过$$(lastword $$(MAKEFILE_LIST))拿到最后读取的makefile，然后通过$(patsubst %/,%,$(dir $(LOCAL_MODULE_MAKEFILE)))得到最后读取的makefile的路径。 最后要知道gnu make 会自动将所有读取的makefile路径都会加入到MAKEFILE_LIST变量中，而且是按照读取的先后顺序添加。 那么分析开始了，在运行本makefile文件时，$(MAKEFILE_LIST)字符串中最后一个makefile肯定是最后读取的makefile，即$(lastword $(MAKEFILE_LIST))则会返回当前路径/Android.mk，my-dir函数则会得到当前路径。 如果我们在include $(CLEAR_VARS)之后，再调用my-dir函数，那么$$(lastword $$(MAKEFILE_LIST))肯定就会返回build/core/clear_vars.mk，my-dir函数得到的值就是build/core，而不是当前的路径了。 这么一来得到的LOCAL_PATH的值就是错误的值，依赖LOCAL_PATH的其他变量也就更加不可能是正确的了！所以说 ，LOCAL_PATH必须要在任何including $(CLEAR_VARS))之前定义 。 编译静态库、动态库、apk、签名版apk等模块的Android.mk要怎么写请看Android.mk写法实例。 为了方便模块的编译，Build 系统设置了很多的编译环境变量。要编译一个模块，只要在编译之前根据需要设置这些变量然后执行编译即可。它们包括： LOCAL_SRC_FILES：当前模块包含的所有源代码文件。 LOCAL_MODULE：当前模块的名称，这个名称应当是唯一的，模块间的依赖关系就是通过这个名称来引用的。 LOCAL_C_INCLUDES：C 或 C++ 语言需要的头文件的路径。 LOCAL_STATIC_LIBRARIES：当前模块在静态链接时需要的库的名称。 LOCAL_SHARED_LIBRARIES：当前模块在运行时依赖的动态库的名称。 LOCAL_CFLAGS：提供给 C/C++ 编译器的额外编译参数。 LOCAL_JAVA_LIBRARIES：当前模块依赖的 Java 共享库。 LOCAL_STATIC_JAVA_LIBRARIES：当前模块依赖的 Java 静态库。 LOCAL_PACKAGE_NAME：当前 APK 应用的名称。 LOCAL_CERTIFICATE：签署当前应用的证书名称。 LOCAL_MODULE_TAGS：当前模块所包含的标签，一个模块可以包含多个标签。标签的值可能是 debug, eng或者optional。其中optional 是默认标签。标签是提供给编译类型TARGET_BUILD_VARIANT使用的。不同的编译类型会安装包含不同标签的模块，关于编译类型的说明下面来讲。 编译和安装 首先我们要知道并不是所有编译了的模块都会安装打包进img，有的模块是只编译不安装的哦！ module 在单独mmm编译的时候，是可以安装到out中的system对应位置的，最后能够打包进系统的system.img。 但是如果整体的 make -j 编译系统，那么module就会先生成在out下的*symbols/system对应的位置，最后会不会打包进系统system.img要看module 的LOCAL_MODULE_TAGS和当前的编译的TARGET_BUILD_VARIANT没有满足下面表格中的规则。 三种编译类型TARGET_BUILD_VARIANT与安装模块的规则 名称 详细说明 eng 默认类型，该编译类型适用于开发阶段。当选择这种类型时，编译结果将：安装包含 eng, debug标签的模块;安装所有没有标签的非 APK 模块;安装所有PRODUCT_PACKAGES宏中指定的 APK 模块;编译出的系统具有 root 访问权限;ro.secure=0;ro.debuggable=1;ro.kernel.android.checkjni=1;adb enabled userdebug 该编译类型适合用于 debug 阶段。当选择这种类型时，编译结果将：安装所有带有 debug标签的模块;安装所有没有标签的非 APK 模块;安装所有PRODUCT_PACKAGES宏中指定的 APK 模块编译出的系统具有 root 访问权限;ro.secure=1;ro.debuggable=1;adb enabled user 该编译类型适合用于最终发布阶段。当选择这种类型时，编译结果将：安装所有没有标签的非 APK 模块;忽略APK 模块的标签，安装哪些模块只依赖PRODUCT_PACKAGES宏;编译出的系统不具有 root 访问权限;ro.secure=1;ro.debuggable=0;关闭log, console, adb, 编译出odex odex的作用：系统制作会把.odex 和 apk 一起放到system/app 下，由系统来调度使用，如果想盗版apk，单独copy出去.apk是不能用的，这样可以起到一定程度上的保护作用！ 表格里的文字看晕了的话记住下面这张图就好了： 总结： 这里可以看到对module的安装控制级别最高的是 PRODUCT_PACKAGES 这个变量。 不满足的规则的module只会被编译，并不会被install 的。 如果需要安装打包进system.img则可以按照上面表格中的规则，修改module的 LOCAL_MODULE_TAGS 或者在 PRODUCT_PACKAGES 中添加 module。 比如： LOCAL_MODULE_TAGS的默认值是optional，则该module会被编译但不会install。如果希望install的话可以： PRODUCT_PACKAGES += 该module名称 修改LOCAL_MODULE_TAGS := 对应的TARGET_BUILD_VARIANT(eng/debug) 常见模块名称 暂时就写这么多啦，以后有需要再补充~ 欢迎指导和提意见 Written with StackEdit. "},"Android/Build/porting.apk.to.4.4.4.html":{"url":"Android/Build/porting.apk.to.4.4.4.html","title":"Porting Apk To 4 4 4","keywords":"","body":"问题： MoosLauncher.apk是在android studio中开发的，放到aosp 7.1.2以及8.1.0上都可以编过： file Android.mk: LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE := MoosLauncher LOCAL_MODULE_TAGS := optional LOCAL_DEX_PREOPT:= false LOCAL_SRC_FILES := launcher3/build/MoosLauncher.apk LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX) LOCAL_CERTIFICATE := PRESIGNED LOCAL_MODULE_CLASS := APPS include $(BUILD_PREBUILT) 但是放到aosp 4.4.4上出现了报错，out/host/linux-x86/bin/zipalign无法对此apk进行优化： target Prebuilt APK: MoosLauncher (out/target/product/rk312x/obj/APPS/MoosLauncher_intermediates/MoosLauncher.apk) out/host/linux-x86/bin/zipalign -f 4 packages/apps/MoosLauncher/launcher3/build/MoosLauncher.apk out/target/product/rk312x/obj/APPS/MoosLauncher_intermediates/MoosLauncher.apk build/core/prebuilt.mk:151: recipe for target 'out/target/product/rk312x/obj/APPS/MoosLauncher_intermediates/MoosLauncher.apk' failed make: [out/target/product/rk312x/obj/APPS/MoosLauncher_intermediates/MoosLauncher.apk] Error 1 make: Deleting file 'out/target/product/rk312x/obj/APPS/MoosLauncher_intermediates/MoosLauncher.apk' // todo zipalign 作用：优化apk res文件，对齐，运行速度加快 解决办法： 安卓4.4.4版本上弃用Android.mk，改用PRODUCT_COPY_FILES += packages/apps/MoosLauncher/launcher3/build/MoosLauncher.apk:system/priv-app/MoosLauncher.apk 修改build/core/Makefile中的error为warning: define check-product-copy-files $(if $(filter %.apk, $(1)),$(error \\ Prebuilt apk found in PRODUCT_COPY_FILES: $(1), use BUILD_PREBUILT instead!)) endef 改成 define check-product-copy-files $(if $(filter %.apk, $(1)),$(warning \\ Prebuilt apk found in PRODUCT_COPY_FILES: $(1), use BUILD_PREBUILT instead!)) endef "},"Android/JNI/jni.html":{"url":"Android/JNI/jni.html","title":"Jni","keywords":"","body":"[TOC] JNI: Java Native Interface 参考书：深入理解Android卷I 第二章深入理解JNI 参考代码：http://androidxref.com/9.0.0_r3 参考笔记： https://juejin.im/post/5b42a9a86fb9a04f8a216b67 简介 目的：java & c/c++可以互相调用对方的函数 对java层屏蔽不同操作系统的差异 native已经实现的功能可以直接用，避免重复造轮子 native实现部分的运行效率和速度快 Java(MediaScanner) JNI(libmedia_jni.so) Native(libmedia.so) 观察MediaScanner.java中的native方法： public class MediaScanner { static { System.loadLibrary(\"media_jni\"); // 根据不同平台扩展，linux下扩展为libmedia_jni.so, windows下扩展为media_jni.dll native_init(); } ... private native boolean processFile(String path, String mimeType, MediaScannerClient client); private static native final void native_init(); } 观察android_media_MediaScanner.cpp中两个native方法的实现： native_init() static void android_media_MediaScanner_native_init(JNIEnv *env) { ALOGV(\"native_init\"); jclass clazz = env->FindClass(kClassMediaScanner); if (clazz == NULL) { return; } fields.context = env->GetFieldID(clazz, \"mNativeContext\", \"J\"); if (fields.context == NULL) { return; } } private native void processFile(String path, String mimeType, MediaScannerClient client); static jboolean android_media_MediaScanner_processFile( JNIEnv *env, jobject thiz, jstring path, jstring mimeType, jobject client) { ALOGV(\"processFile\"); // Lock already hold by processDirectory MediaScanner *mp = getNativeScanner_l(env, thiz); if (mp == NULL) { jniThrowException(env, kRunTimeException, \"No scanner available\"); return false; } if (path == NULL) { jniThrowException(env, kIllegalArgumentException, NULL); return false; } const char *pathStr = env->GetStringUTFChars(path, NULL); if (pathStr == NULL) { // Out of memory return false; } const char *mimeTypeStr = (mimeType ? env->GetStringUTFChars(mimeType, NULL) : NULL); if (mimeType && mimeTypeStr == NULL) { // Out of memory // ReleaseStringUTFChars can be called with an exception pending. env->ReleaseStringUTFChars(path, pathStr); return false; } MyMediaScannerClient myClient(env, client); MediaScanResult result = mp->processFile(pathStr, mimeTypeStr, myClient); if (result == MEDIA_SCAN_RESULT_ERROR) { ALOGE(\"An error occurred while scanning file '%s'.\", pathStr); } env->ReleaseStringUTFChars(path, pathStr); if (mimeType) { env->ReleaseStringUTFChars(mimeType, mimeTypeStr); } return result != MEDIA_SCAN_RESULT_ERROR; } java native关键字 该方法的实现由非java语言实现，比如C。这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在C＋＋中，你可以用extern \"C\"告知C＋＋编译器去调用一个C的函数; 标识符native不能与abstract连用; 如果一个含有native方法的类被继承，子类会继承这个本地方法并且可以用java语言重写这个方法（这个似乎看起来有些奇怪），同样的如果一个本地方法被final标识，它被继承后不能被重写。 如何注册 JNI HelloWorld实例: 静态注册 参考 https://blog.csdn.net/xyang81/article/details/41777471 自己实现JNI Helloworld https://gist.github.com/FrannyZhao/3fb01202e598495033744a40bc841d2e 静态注册是根据函数名来建立Java函数和JNI函数的对应关系的（.对应 _ , _ 对应 _1）. 弊端： 需要编译所有包含native方法的Java类，每个.class都需要用javah生成一个头文件； javah生成的JNI函数名特别长，用起来不太方便； 初次调用native函数时需要通过函数名字搜索对应的JNI层函数来建立关联关系，会影响效率。 用动态注册来解决上面的弊端 观察android_media_MediaScanner.cpp中JNINativeMethod, 标示了native函数的对应关系： static const JNINativeMethod gMethods[] = { ... { \"processFile\", // java中native函数的名字 \"(Ljava/lang/String;Ljava/lang/String;Landroid/media/MediaScannerClient;)Z\", // java函数的签名信息，是参数类型和返回值类型的组合 (void *)android_media_MediaScanner_processFile //JNI层对应函数的函数指针，注意它是void*类型 }, ... { \"native_init\", \"()V\", (void *)android_media_MediaScanner_native_init }, ... }; 这个数组是这样被注册的： 调用android_media_MediaPlayer.cpp中的register_android_media_MediaScanner: extern int register_android_media_MediaScanner(JNIEnv *env); ... jint JNI_OnLoad(JavaVM* vm, void* /* reserved */) { JNIEnv* env = NULL; jint result = -1; if (vm->GetEnv((void**) &env, JNI_VERSION_1_4) != JNI_OK) { ALOGE(\"ERROR: GetEnv failed\\n\"); goto bail; } assert(env != NULL); if (register_android_media_ImageWriter(env) != JNI_OK) { ALOGE(\"ERROR: ImageWriter native registration failed\"); goto bail; } ... if (register_android_media_MediaScanner(env) register_android_media_MediaScanner中注册JNINativeMethod数组 int register_android_media_MediaScanner(JNIEnv *env) { return AndroidRuntime::registerNativeMethods(env, kClassMediaScanner, gMethods, NELEM(gMethods)); //调用AndroidRuntime的registerNativeMethods函数，第二个参数表明是java中哪个累 } AndroidRuntime.cpp中的registerNativeMethods函数： int AndroidRuntime::registerNativeMethods(JNIEnv* env, const char* className, const JNINativeMethod* gMethods, int numMethods) { return jniRegisterNativeMethods(env, className, gMethods, numMethods); //调用jniRegisterNativeMethods完成注册 } JNIHelp.cpp中的jniRegisterNativeMethods函数： extern \"C\" int jniRegisterNativeMethods(C_JNIEnv* env, const char* className, const JNINativeMethod* gMethods, int numMethods) { JNIEnv* e = reinterpret_cast(env); ALOGV(\"Registering %s's %d native methods...\", className, numMethods); scoped_local_ref c(env, findClass(env, className)); if (c.get() == NULL) { char* tmp; const char* msg; if (asprintf(&tmp, \"Native registration unable to find class '%s'; aborting...\", className) == -1) { // Allocation failed, print default warning. msg = \"Native registration unable to find class; aborting...\"; } else { msg = tmp; } e->FatalError(msg); } //实际上是调用JNIEnv的RegisterNatives函数完成注册的 if ((*env)->RegisterNatives(e, c.get(), gMethods, numMethods) FatalError(msg); } return 0; } 总结：JVM加载native方法和注册流程 Created with Raphaël 2.1.4JVM加载包含native方法的类该类的字节码会被加载到内存，在这个被加载的字节码的入口维持着一个该类所有方法描述符的list，这些方法描述符包含这样一些信息：方法代码存于何处，它有哪些参数，方法的描述符（public之类）等等;如果一个方法描述符内有native，这个描述符块将有一个指向该方法的实现的指针通过调用java.system.loadLibrary(\"xxx\")加载DLL或SO以下实现在加载的lib中查找该库中的JNI_OnLoad函数，如果有，就调用它，完成动态注册（静态注册根据函数名完成对应关系，不需要实现这个方法）register_android_media_MediaScanner(env)AndroidRuntime::registerNativeMethods(env, kClassMediaScanner, gMethods, NELEM(gMethods)); JNINativeMethod gMethods中定义了函数对应关系jniRegisterNativeMethods(env, className, gMethods, numMethods);(*env)- >FindClass(env, className);(*env)- >RegisterNatives(env, clazz, gMethods, numMethods)JNI_OnLoad return JNI_VERSION_1_4 //必须返回这个值，否则会报错 Java和JNI层数据类型转换 基本数据类型 hih JNIEnv 简介 JNIEnv类型实际上代表了Java环境，通过这个JNIEnv* 指针，就可以对Java端的代码进行操作。例如，创建Java类中的对象，调用Java对象的方法，获取Java对象中的属性等等。JNIEnv的指针会被JNI传入到本地方法的实现函数中来对Java端的代码进行操作。 JNIEnv类中有很多函数可以用： NewObject:创建Java类中的对象 NewString:创建Java类中的String对象 NewArray:创建类型为Type的数组对象 GetField:获取类型为Type的字段 SetField:设置类型为Type的字段的值 例如：GetObjectField()SetObjectField() GetBooleanField()SetBooleanField() GetByteField()SetByteField() GetCharField()SetCharField() GetShortField()SetShortField() GetIntField()SetIntField() GetLongField()SetLongField() GetFloatField()SetFloatField() GetDoubleField()SetDoubleField() GetStaticField:获取类型为Type的static的字段 SetStaticField:设置类型为Type的static的字段的值 CallMethod:调用返回类型为Type的方法 CallStaticMethod:调用返回值类型为Type的static方法 等许多的函数，具体的可以查看jni.h文件中的函数名称。 全进程只有一个JavaVM对象： jint JNI_OnLoad(JavaVM*vm,void*reserved) JNIEnv是一个与线程相关的变量: 调用JavaVM的AttachCurrentThread函数，就可得到这个线程的JNIEnv结构体。这样就可以在后台线程中回调Java函数了。 另外，在后台线程退出前，需要调用JavaVM的DetachCurrentThread函数来释放对应的资源。 实例： 1. 保存jfieldID和jmethodID 如果每次操作jobject前都去查询jmethodID或jfieldID，那么将会影响程序运行的效率，所以我们在初始化的时候可以取出这些ID并保存起来以供后续使用。 class MyMediaScannerClient : public MediaScannerClient { public: MyMediaScannerClient(JNIEnv *env, jobject client) : mEnv(env), mClient(env->NewGlobalRef(client)), mScanFileMethodID(0), mHandleStringTagMethodID(0), mSetMimeTypeMethodID(0) { ALOGV(\"MyMediaScannerClient constructor\"); jclass mediaScannerClientInterface = env->FindClass(kClassMediaScannerClient); //先找到android.media.MediaScannerClient类在JNI层中对应的jclass实例。 if (mediaScannerClientInterface == NULL) { ALOGE(\"Class %s not found\", kClassMediaScannerClient); } else { mScanFileMethodID = env->GetMethodID( mediaScannerClientInterface, \"scanFile\", \"(Ljava/lang/String;JJZZ)V\"); //取出MediaScannerClient类中函数scanFile的jMethodID。 ... } } } 2.使用jfieldID和jmethodID 通过JNIEnv的CallVoidMethod（CallMethod, 其中type对应Java函数的返回值类型，例如CallIntMethod、CallVoidMethod），再把jobject、jMethodID和对应的参数传进去，JNI层就能够调用Java对象的函数了。 virtual status_t scanFile(const char* path, long long lastModified, long long fileSize, bool isDirectory, bool noMedia) { ALOGV(\"scanFile: path(%s), time(%lld), size(%lld) and isDir(%d)\", path, lastModified, fileSize, isDirectory); jstring pathStr; if ((pathStr = mEnv->NewStringUTF(path)) == NULL) { mEnv->ExceptionClear(); return NO_MEMORY; } mEnv->CallVoidMethod(mClient, mScanFileMethodID, pathStr, lastModified, fileSize, isDirectory, noMedia); /* 调用JNIEnv的CallVoidMethod函数，注意CallVoidMethod的参数： 第一个是代表MediaScannerClient的jobject对象， 第二个参数是函数scanFile的jmethodID，后面是Java中scanFile的参数。 */ mEnv->DeleteLocalRef(pathStr); return checkAndClearExceptionFromCallback(mEnv, \"scanFile\"); } 垃圾回收和异常处理 "},"Android/WorkExperience/add.custom.libarary.html":{"url":"Android/WorkExperience/add.custom.libarary.html","title":"Add Custom Libarary","keywords":"","body":"Not accessible for namespace 参考https://www.jianshu.com/p/4be3d1dafbec 问题： 做图像对比需要在/system/lib下加入一个新的库libopencv_java4.so 在安卓低版本上没问题，在高版本上报了个错误： System.err: java.lang.UnsatisfiedLinkError: dlopen failed: library \"/system/lib/libopencv_java4.so\" needed or dlopened by \"/system/lib/libnativeloader.so\" is not accessible for the namespace \"classloader-namespace\" 搜索了一下，原来是普通应用不能直接引用系统的一些so库了，只能直接引用public.libraries.txt文件中过滤的so库。这个网址有介绍怎么处理。 https://source.android.com/devices/tech/config/namespaces_libraries 解决： diff --git a/rootdir/etc/public.libraries.android.txt b/rootdir/etc/public.libraries.android.txt index 5482085..d65453d 100644 --- a/rootdir/etc/public.libraries.android.txt +++ b/rootdir/etc/public.libraries.android.txt @@ -23,3 +23,4 @@ libsync.so libvulkan.so libwebviewchromium_plat_support.so libz.so +libopencv_java4.so "},"Android/WorkExperience/android.adatper.html":{"url":"Android/WorkExperience/android.adatper.html","title":"Android Adatper","keywords":"","body":"[TOC] 安卓适配 屏幕适配 用AndroidStudio插件ScreenMatch根据屏幕尺寸生成不同的dimen https://www.jianshu.com/p/1302ad5a4b04 https://github.com/wildma/ScreenAdaptation/blob/master/app/src/main/res/values/dimens.xml 不能应对density变化？ 用限制性布局ConstraintLayout 少用dp值，多用百分比 可以应对density变化 implementation 'com.android.support.constraint:constraint-layout:1.1.3' 图片用.9或者svg; 多用相对布局，尽量不用绝对布局； 通过gradle flavor选择不同的sourceset 用自适应textview https://blog.csdn.net/Virgil_K2017/article/details/88725298 "},"Android/WorkExperience/force.landscape.html":{"url":"Android/WorkExperience/force.landscape.html","title":"Force Landscape","keywords":"","body":"[TOC] Android强制更改为横屏方案 参考https://blog.csdn.net/songjinshi/article/details/50586333 增加了应用层的修改，防止有的应用写了screenOrientation = portrait, 或者request orientation portrait 增加了recovery显示的旋转 frameworks/native SurfaceFlinger的DispalyDevice diff --git a/services/surfaceflinger/DisplayDevice.cpp b/services/surfaceflinger/DisplayDevice.cpp index 6128890..3d92e49 100644 --- a/services/surfaceflinger/DisplayDevice.cpp +++ b/services/surfaceflinger/DisplayDevice.cpp @@ -189,7 +189,8 @@ DisplayDevice::DisplayDevice( } // initialize the display orientation transform. - setProjection(DisplayState::eOrientationDefault, mViewport, mFrame); + //setProjection(DisplayState::eOrientationDefault, mViewport, mFrame); + setProjection(DisplayState::eOrientation90, mViewport, mFrame); if (useTripleFramebuffer) { surface->allocateBuffers(); @@ -563,6 +564,10 @@ void DisplayDevice::setProjection(int orientation, // the destination frame can be invalid if it has never been set, // in that case we assume the whole display frame. frame = Rect(w, h); + if (R.getOrientation() & Transform::ROT_90) { + // for force landscape + swap(frame.right, frame.bottom); + } } if (viewport.isEmpty()) { frameworks/base 开机动画，宽高对调 diff --git a/cmds/bootanimation/BootAnimation.cpp b/cmds/bootanimation/BootAnimation.cpp index 6526123..abb8510 100644 --- a/cmds/bootanimation/BootAnimation.cpp +++ b/cmds/bootanimation/BootAnimation.cpp @@ -258,7 +258,8 @@ status_t BootAnimation::readyToRun() { // create the native surface sp control = session()->createSurface(String8(\"BootAnimation\"), - dinfo.w, dinfo.h, PIXEL_FORMAT_RGB_565); + dinfo.h, dinfo.w, PIXEL_FORMAT_RGB_565); + //dinfo.w, dinfo.h, PIXEL_FORMAT_RGB_565); SurfaceComposerClient::openGlobalTransaction(); control->setLayer(0x40000000); framework层 diff --git a/services/core/java/com/android/server/policy/PhoneWindowManager.java b/services/core/java/com/android/server/policy/PhoneWindowManager.java index e81fd66..bfd068a 100644 --- a/services/core/java/com/android/server/policy/PhoneWindowManager.java +++ b/services/core/java/com/android/server/policy/PhoneWindowManager.java @@ -7167,7 +7167,9 @@ public class PhoneWindowManager implements WindowManagerPolicy { ? \"USER_ROTATION_LOCKED\" : \"\") ); } - + if (true) { + return mLandscapeRotation; + } if (mForceDefaultOrientation) { return Surface.ROTATION_0; } diff --git a/services/core/java/com/android/server/wm/DisplayContent.java b/services/core/java/com/android/server/wm/DisplayContent.java index a49f447..be35409 100644 --- a/services/core/java/com/android/server/wm/DisplayContent.java +++ b/services/core/java/com/android/server/wm/DisplayContent.java @@ -233,7 +233,7 @@ class DisplayContent extends WindowContainer 应用层 diff --git a/core/java/android/app/Activity.java b/core/java/android/app/Activity.java index bfa35da..e0c53eb 100644 --- a/core/java/android/app/Activity.java +++ b/core/java/android/app/Activity.java @@ -5773,12 +5773,12 @@ public class Activity extends ContextThemeWrapper if (mParent == null) { try { ActivityManager.getService().setRequestedOrientation( - mToken, requestedOrientation); + mToken, 0); } catch (RemoteException e) { // Empty } } else { - mParent.setRequestedOrientation(requestedOrientation); + mParent.setRequestedOrientation(0); } } diff --git a/core/java/android/content/pm/PackageParser.java b/core/java/android/content/pm/PackageParser.java index 750bad6..6b34af6 100644 --- a/core/java/android/content/pm/PackageParser.java +++ b/core/java/android/content/pm/PackageParser.java @@ -4378,9 +4378,7 @@ public class PackageParser { a.info.flags |= ActivityInfo.FLAG_RESUME_WHILE_PAUSING; } - a.info.screenOrientation = sa.getInt( - R.styleable.AndroidManifestActivity_screenOrientation, - SCREEN_ORIENTATION_UNSPECIFIED); + a.info.screenOrientation = 0; setActivityResizeMode(a.info, sa, owner); @@ -4810,7 +4808,7 @@ public class PackageParser { if (info.descriptionRes == 0) { info.descriptionRes = target.info.descriptionRes; } - info.screenOrientation = target.info.screenOrientation; + info.screenOrientation = 0; info.taskAffinity = target.info.taskAffinity; info.theme = target.info.theme; info.softInputMode = target.info.softInputMode; bootable/recovery recovery UI diff --git a/screen_ui.cpp b/screen_ui.cpp index b8f6ea2..69db797 100644 --- a/screen_ui.cpp +++ b/screen_ui.cpp @@ -170,8 +170,8 @@ void ScreenRecoveryUI::draw_background_locked() { } GRSurface* text_surface = GetCurrentText(); - int text_x = (gr_fb_width() - gr_get_width(text_surface)) / 2; - int text_y = GetTextBaseline(); + int text_x = (gr_fb_width() - gr_get_width(text_surface)) / 3; //(gr_fb_width() - gr_get_width(text_surface)) / 2; + int text_y = (gr_fb_height() - gr_get_height(text_surface)) / 2; //GetTextBaseline(); gr_color(255, 255, 255, 255); gr_texticon(text_x, text_y, text_surface); } @@ -184,8 +184,8 @@ void ScreenRecoveryUI::draw_foreground_locked() { GRSurface* frame = GetCurrentFrame(); int frame_width = gr_get_width(frame); int frame_height = gr_get_height(frame); - int frame_x = (gr_fb_width() - frame_width) / 2; - int frame_y = GetAnimationBaseline(); + int frame_x = (gr_fb_width() - frame_width) * 2 / 3; //(gr_fb_width() - frame_width) / 2; + int frame_y = (gr_fb_height() - frame_height) / 2; //GetAnimationBaseline(); gr_blit(frame, 0, 0, frame_width, frame_height, frame_x, frame_y); } @@ -460,6 +460,7 @@ void ScreenRecoveryUI::LoadBitmap(const char* filename, GRSurface** surface) { void ScreenRecoveryUI::LoadLocalizedBitmap(const char* filename, GRSurface** surface) { int result = res_create_localized_alpha_surface(filename, locale_.c_str(), surface); + RotateSurface(*surface); if (result pixel_bytes != 1) return; + int data_size = surface->height * surface->row_bytes; + unsigned char* src = new unsigned char[data_size]; + if (src == NULL) return; + memcpy(src, surface->data, data_size); + unsigned char *dst = surface->data; + int width = surface->width, height = surface->height; + for (int j = 0; j row_bytes; + unsigned char *px = dst + (height - 1 - j) * surface->pixel_bytes; + for (int i = 0; i width = height; + surface->height = width; + surface->row_bytes = surface->pixel_bytes * surface->width; + delete []src; + return; +} + diff --git a/screen_ui.h b/screen_ui.h index 8231a2b..6ccd232 100644 --- a/screen_ui.h +++ b/screen_ui.h @@ -191,6 +191,9 @@ class ScreenRecoveryUI : public RecoveryUI { // Similar to DrawTextLines() to draw multiple text lines, but additionally wraps long lines. // Returns the offset it should be moving along Y-axis. int DrawWrappedTextLines(int x, int y, const char* const* lines) const; + + // Rotate 90 degree + void RotateSurface(GRSurface *); }; #endif // RECOVERY_UI_H "},"Android/WorkExperience/launcher.html":{"url":"Android/WorkExperience/launcher.html","title":"Launcher","keywords":"","body":"[TOC] Launcher获取全部应用列表，并监听应用增删 获取全部应用列表 安卓L以后 通过LauncherApps.getActivityList获得 LauncherApps mLauncherApps = (LauncherApps) context.getSystemService(Context.LAUNCHER_APPS_SERVICE); @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP) public List getAllApps(Context context) { List allApps = new ArrayList<>(); UserManager mUserManager = (UserManager) context.getSystemService(Context.USER_SERVICE); for (UserHandle user : mUserManager.getUserProfiles()) { List lais = mLauncherApps.getActivityList(null, user); allApps.addAll(lais); } return allApps; } 获得应用图标，名称，启动intent LauncherActivityInfo launcherActivityInfo = mAppsHighVersion.get(position); holder.appName.setText(launcherActivityInfo.getLabel().toString()); holder.appIcon.setImageDrawable(launcherActivityInfo.getIcon(320)); holder.rootView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { mLauncher.startActivity(mPackageManager.getLaunchIntentForPackage(launcherActivityInfo.getApplicationInfo().packageName)); stopAnimation(); } }); 安卓4.4.4 通过PackageManager.queryIntentActivities获得全部应用 public List getAllApps(Context context) { PackageManager pm = context.getPackageManager(); Intent launchable = new Intent(Intent.ACTION_MAIN); launchable.addCategory(Intent.CATEGORY_LAUNCHER); final List allApps = pm.queryIntentActivities(launchable, 0); return allApps; } 获得应用图标，名称，启动Intent ResolveInfo resolveInfo = mAppsLowVersion.get(position); holder.appName.setText(resolveInfo.activityInfo.applicationInfo.loadLabel(mPackageManager)); holder.appIcon.setImageDrawable(resolveInfo.activityInfo.applicationInfo.loadIcon(mPackageManager)); holder.rootView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { mLauncher.startActivity(mPackageManager.getLaunchIntentForPackage(resolveInfo.activityInfo.packageName)); stopAnimation(); } }); 监听应用增删 安卓L以后 注册回调LauncherApps.Callback public class AppStateManager { private static final String TAG = AppStateManager.class.getSimpleName(); private static volatile AppStateManager instance = null; private LauncherApps mLauncherApps; private AppStateCallback mCallback; private Object mCallbackLock = new Object(); private final HandlerThread mCallbackThread = new HandlerThread(\"callback\"); @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP) private AppStateManager(Context context) { mCallbackThread.start(); mLauncherApps = (LauncherApps) context.getSystemService(Context.LAUNCHER_APPS_SERVICE); synchronized (mCallbackLock) { if (mCallback != null) { mLauncherApps.unregisterCallback(mCallback); } } mCallback = new AppStateCallback(); mLauncherApps.registerCallback(mCallback, new Handler(mCallbackThread.getLooper())); } @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP) public void unregister() { synchronized (mCallbackLock) { if (mCallback != null) { mLauncherApps.unregisterCallback(mCallback); mCallback = null; } } } @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP) private class AppStateCallback extends LauncherApps.Callback { private final String TAG = AppStateCallback.class.getSimpleName(); @Override public void onPackageRemoved(String packageName, UserHandle user) { Log.i(TAG, \"onPackageRemoved packageName \" + packageName + \", user \" + user); } @Override public void onPackageAdded(String packageName, UserHandle user) { Log.i(TAG, \"onPackageAdded packageName \" + packageName + \", user \" + user); } @Override public void onPackageChanged(String packageName, UserHandle user) { Log.i(TAG, \"onPackageChanged packageName \" + packageName + \", user \" + user); } @Override public void onPackagesAvailable(String[] packageNames, UserHandle user, boolean replacing) { Log.i(TAG, \"onPackagesAvailable packageNames \" + Arrays.toString(packageNames) + \", user \" + user + \", replacing \" + replacing); } @Override public void onPackagesUnavailable(String[] packageNames, UserHandle user, boolean replacing) { Log.i(TAG, \"onPackagesUnavailable packageNames \" + Arrays.toString(packageNames) + \", user \" + user + \", replacing \" + replacing); } } @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP) public static AppStateManager getInstance(Context context) { if (instance == null) { synchronized (AppStateManager.class) { if (instance == null) { instance = new AppStateManager(context); } } } return instance; } } 安卓4.4.4 监听广播Intent.ACTION_PACKAGE_ADDED， Intent.ACTION_PACKAGE_REMOVED， Intent.ACTION_PACKAGE_CHANGED private void register(Context context) { IntentFilter filter = new IntentFilter(Intent.ACTION_PACKAGE_ADDED); filter.addAction(Intent.ACTION_PACKAGE_REMOVED); filter.addAction(Intent.ACTION_PACKAGE_CHANGED); filter.addDataScheme(\"package\"); context.registerReceiver(this, filter); } @Override public void onReceive(Context context, Intent intent) { String action = intent.getAction(); Log.i(TAG, \"receive action \" + action); String packageName = intent.getData().getSchemeSpecificPart(); boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false); if (packageName == null || packageName.length() == 0) { return; } int op = PackageUpdatedTask.OP_NONE; if (Intent.ACTION_PACKAGE_CHANGED.equals(action)) { op = PackageUpdatedTask.OP_UPDATE; } else if (Intent.ACTION_PACKAGE_REMOVED.equals(action)) { if (!replacing) { op = PackageUpdatedTask.OP_REMOVE; } // else, we are replacing the package, so a PACKAGE_ADDED will be sent // later, we will update the package at this time } else if (Intent.ACTION_PACKAGE_ADDED.equals(action)) { if (!replacing) { op = PackageUpdatedTask.OP_ADD; } else { op = PackageUpdatedTask.OP_UPDATE; } } Log.i(TAG, \"op \" + op); if (op != PackageUpdatedTask.OP_NONE) { notifyAppState(); } } private class PackageUpdatedTask { int mOp; public static final int OP_NONE = 0; public static final int OP_ADD = 1; public static final int OP_UPDATE = 2; public static final int OP_REMOVE = 3; // uninstlled public static final int OP_UNAVAILABLE = 4; // external media unmounted } 源码：https://github.com/FrannyZhao/LauncherDemo Android原生Launcher源码更多分析参考： Android 7.0 Launcher3源码实现全解析 https://blog.csdn.net/kuaiguixs/article/details/78818788 https://blog.csdn.net/kuaiguixs/article/details/78904196 https://blog.csdn.net/kuaiguixs/article/details/78890509 Android M Launcher3主流程源码浅析 https://github.com/FrannyZhao/LauncherDemo 衍生阅读： Android Launcher 启动 Activity 的工作过程 https://blog.csdn.net/qian520ao/article/details/78156214 "},"Android/WorkExperience/set.default.IME.html":{"url":"Android/WorkExperience/set.default.IME.html","title":"Set Default IME","keywords":"","body":"[TOC] Android 修改默认输入法 安卓会根据系统设置的国家地区locale选择匹配的输入法，比如当前是中国地区，匹配的输入法是中文输入法（如果系统里面安装了中文输入法的话）。 项目有个奇怪的需求是无论locale是哪里，默认的输入法都要是英文输入法。 那么就要修改framework层设置默认IME的代码了。 我只验证了安卓4.4.4,7.1.2,8.1.0这三个版本，思路都是一样的，就是找到设置默认IME的地方，返回我们想要的IME即可。 7.1.2 & 8.1.0 frameworks/base/core/java/com/android/internal/inputmethod/InputMethodUtils.java public InputMethodListBuilder fillImes(final ArrayList imis, final Context context, final boolean checkDefaultAttribute, @Nullable final Locale locale, final boolean checkCountry, final String requiredSubtypeMode) { for (int i = 0; i 4.4.4 frameworks/base/core/java/com/android/internal/inputmethod/InputMethodUtils.java public static ArrayList getDefaultEnabledImes( Context context, boolean isSystemReady, ArrayList imis) { final ArrayList retval = new ArrayList(); boolean auxilialyImeAdded = false; for (int i = 0; i frameworks/base/services/java/com/android/server/InputMethodManagerService.java diff --git a/frameworks/base/services/java/com/android/server/InputMethodManagerService.java b/frameworks/base/services/java/com/android/server/InputMethodManagerService.java index 16b2d4d..0ff5006 100755 --- a/frameworks/base/services/java/com/android/server/InputMethodManagerService.java +++ b/frameworks/base/services/java/com/android/server/InputMethodManagerService.java @@ -724,8 +724,9 @@ public class InputMethodManagerService extends IInputMethodManager.Stub InputMethodInfo defIm = null; for (InputMethodInfo imi : mMethodList) { if (defIm == null) { - if (InputMethodUtils.isValidSystemDefaultIme( - mSystemReady, imi, context)) { +// if (InputMethodUtils.isValidSystemDefaultIme( +// mSystemReady, imi, context)) { + if (imi.getId().equals(\"com.android.inputmethod.latin/.LatinIME\")) { defIm = imi; Slog.i(TAG, \"Selected default: \" + imi.getId()); } "},"Basic_Knowledge/shift.html":{"url":"Basic_Knowledge/shift.html","title":"Shift","keywords":"","body":"数字编码： 参考： https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html 原码：符号位+真值 反码：正数同原码，负数：符号位不变，真值取反 补码：正数同原码，负数：符号位不变，真值取反+1 目的：简化计算机的基础电路，将符号位也参与运算，这样所以机器可以只有加法而没有减法 补码的补码 = 原码 数学原理： 同余定理 Java位移 参考： https://blog.csdn.net/qq_41892229/article/details/82874928 byte的取值范围为-128~127，占用1个字节（-2的7次方到2的7次方-1） short的取值范围为-32768~32767，占用2个字节（-2的15次方到2的15次方-1） int的取值范围为（-2147483648~2147483647），占用4个字节（-2的31次方到2的31次方-1） long的取值范围为（-9223372036854774808~9223372036854774807），占用8个字节（-2的63次方到2的63次方-1） 左移 高位移除，在低位补0； 在没有数字溢出的前提下，左移1位相当于乘以2的1次方，左移n位相当于乘以2的n次方。 在左移过程中正数可能移为负数，负数也可能移为正数。 当左移的操作数是int类型时，每移动一位它的第31位就要被移除（位数以第0位开始）； 当左移的操作数是long类型时，每移动一位 它的第63位就要被移除； 当左边的操作数为byte、short类型时，它们会被转换为int类型，其结果要是int类型。 -101: 补码 00000000 00000000 00000000 10011011 左移1位：00000000 00000000 00000001 00110110 换算成原码（方便人脑计算数值）：00000000 00000000 00000001 11001010 = -202 右移（有符号）>> 若符号为正，则在高位插入0，若符号为负，则在高位插入1（符号位保持不变）； 操作数为byte、short类型时，它们会被转换为int类型，其结果要是int类型。 右移一位相当于除以2，右移n位相当于除以2的n次方。 无论正负偶数左移一位直接是整除结果，但对于正值奇数结果是除以2后向下取整后的结果。 ​ 对于负值奇数结果是除以2后向上取整结果。 偶数（60） 直接除以2（30） 直接除以2（-30） 奇数（61） 除以2后向下取整（30） 除以2后向上取整（-31） -101: 补码 00000000 00000000 00000000 10011011 有符号右移2位：00000000 00000000 00000000 11100110 换算成原码（方便人脑计算数值）：00000000 00000000 00000000 10011010 = -26 右移（无符号）>>> 无论数值是正数还是负数，都在最高位补0 位移只对32位和64位值有意义 猜测因为位移操作都是在32位寄存器中完成的？？？ 在Thinking in java 中有这么一句话： 只有数值右端的低5位才有用，这样可以防止我们移位超过int型值所具有的位数。（因为2的5次方为32，而int类型只有32位）若对一个long类型的数值进行处理，最后得到的结果也是long类型，此时只会用到数值右端的低6位，以防止移位超过long型数值具有的位数 换言之，如果移动位数超过该类型的最大位数，那么编译器会对移动的位数取模。例如果对int类型移位33位，实际上只移动了33%32=1位。具体细节是（int a "},"CodeManagement/git.useful.skills.html":{"url":"CodeManagement/git.useful.skills.html","title":"Git Useful Skills","keywords":"","body":"[TOC] 为什么用git+gerrit+jenkins三剑客做代码版本控制 烦恼： 经常没有一个好的基础版本来发布和开发，一更新代码发现又跑不起来； 辛苦改好的代码进不去版本库； 不是我的bug却要我来花时间; 开发团队人越多，集成越困难…… 好处： 版本历史有迹可查（git）； 提交前代码检查，坏代码不会污染代码库（gerrit&jenkins）； 快速定位问题； 方便管理多项目； 方便团队合作…… git+gerrit+jenkins三剑客： 灵活，快速，强大，好用。 git各种命令与状态： 想详细了解更多git技能推荐阅读：Git Community Book 中文版 本文挑了最最实用、最最常用的技能，方便大家快速掌握，提高工作效率。 在理解下面的技能前，希望大家先在脑海中形象滴理解下git branch和git commit: 把branch理解成一条流水线，把commit理解成乐高积木。 branch这条流水线是由一个一个commit积木组成的。 更新代码 不要用git pull, 改用git fetch + git rebase 因为git pull会做git merge产生讨厌的merge commit。 merge commit是什么？ git中两个branch合并的时候，需要做个标记，这是我们合并的点，就像两根绳子打个结： 这个结就是git merge时生成的merge commit。 merge commit为啥就讨厌了？ 如果是重要的branch合并，我们会需要个merge commit作为见证。就像结婚说誓词时需要个证婚人一样。 但是你平时说话就不需要见证了，不然太累了。 因为你的本地branch根本不重要，跟主线master合并的时候不需要留下见证。 主线只要你的commit并不想要整个branch。 解决办法： git fetch origin git rebase origin/master git rebase做的动作就是把你的commit挪到主线的最顶端。 rebase过程中出现冲突怎么办？ git status 看下哪个文件冲突了？（假设是src/java/a.java有冲突） 打开这个文件，解决冲突 git add src/java/a.java git rebase --continue 提交 提交前自检： 过一遍自己刚才改了什么 git status git diff git命令都可以加路径来指定文件或者目录，这几个命令也不例外。 比如： git status . 查看当前目录下修改的文件。 git diff src/java/franny.java 查看franny.java文件的具体修改。 提交 git commit git push origin HEAD:refs/for/master git commit . 提交当前目录下修改的文件； git commit src/java/a.java src/java/b.java 只提交a.java, b.java这两个文件。 refs/for 表示提交到gerrit上，走代码review流程，由有权限的人review过才给你合进代码库。 与其对应的是refs/heads和refs/tags直接提交进代码库，普通群众是没有这个权限的就不说了。 还原文件 常用场景： 哎呀，我修改了几十个文件还分散个各种不同目录下，其中有一个文件（假设叫a.java）不需要提交咋办，用git commit file1 file2 file3 ... 太麻烦。 解决办法： 那么就先把a.java还原成未修改的状态： git checkout src/java/a.java 然后git commit -a 一次性提交全部文件。 合并多个提交 常用场景： 哎呀，我的修改提交了2个commit，我想把它们合并成一个commit然后push。 $ git log commit bbb6ca1ddca3b7b59f299c5b9e6bb0c8dc965793 Author: Zhao Fengyi Date: Tue Aug 23 20:10:49 2016 +0800 this is my 3rd commit commit 72fa1768fe5db08323394fe1f4a3fb8d71b7c712 Author: Zhao Fengyi Date: Tue Aug 23 20:10:09 2016 +0800 this is my 2nd commit commit 87ee65f7ff23afacbbe98c62965b243557e3a3e0 Author: Zhao Fengyi Date: Tue Aug 23 20:09:55 2016 +0800 this is my 1st commit 即： 我想把后面的2个提交合并成一个提交。 解决办法有3种： 第一种办法 git reset 把后面2个提交的文件变成未提交状态 git add . ; git commit -am \"blabla\" 把所有为提交的文件一次性提交 具体执行过程： $ git status On branch master nothing to commit, working directory clean $ git reset 87ee65f7ff23afacbbe98c62965b243557e3a3e0 ``` $ git status On branch master Untracked files: (use \"git add ...\" to include in what will be committed) b.java c.java nothing added to commit but untracked files present (use \"git add\" to track) ``` $ git add . ; git commit -am \"merge 2 commits together\" [master 5115542] merge 2 commits together 2 files changed, 24 insertions(+) create mode 100644 src/java/b.java create mode 100644 src/java/c.java $ git log commit 5115542312503fc0422d48e531d12ee506384cd4 Author: Zhao Fengyi Date: Tue Aug 23 20:16:22 2016 +0800 merge 2 commits together commit 87ee65f7ff23afacbbe98c62965b243557e3a3e0 Author: Zhao Fengyi Date: Tue Aug 23 20:09:55 2016 +0800 this is my 1st commit 第二种办法git checkout git merge --squash git commit -a 具体执行过程： ``` $ git checkout 87ee65f7ff23afacbbe98c62965b243557e3a3e0 Note: checking out '87ee65f7ff23afacbbe98c62965b243557e3a3e0'. You are in 'detached HEAD' state. You can look around, make experimental changes and commit them, and you can discard any commits you make in this state without impacting any branches by performing another checkout. If you want to create a new branch to retain commits you create, you may do so (now or later) by using -b with the checkout command again. Example: git checkout -b new_branch_name HEAD is now at 87ee65f... this is my first commit ``` $ git merge 72fa1768fe5db08323394fe1f4a3fb8d71b7c712 bbb6ca1ddca3b7b59f299c5b9e6bb0c8dc965793 --squash Updating 87ee65f..bbb6ca1 Fast-forward Squash commit -- not updating HEAD src/java/b.java | 12 ++++++++++++ src/java/c.java | 12 ++++++++++++ 2 files changed, 24 insertions(+) create mode 100644 src/java/b.java create mode 100644 src/java/c.java $ git status HEAD detached at 87ee65f Changes to be committed: (use \"git reset HEAD ...\" to unstage) new file: b.java new file: c.java $ git commit -a [detached HEAD 0212114] Squashed commit of the following: 2 files changed, 24 insertions(+) create mode 100644 src/java/b.java create mode 100644 src/java/c.java $ git log commit 021211462df14dae5084842b85c0122222dcc453 Author: Zhao Fengyi Date: Tue Aug 23 20:26:32 2016 +0800 Squashed commit of the following: commit bbb6ca1ddca3b7b59f299c5b9e6bb0c8dc965793 Author: Zhao Fengyi Date: Tue Aug 23 20:10:49 2016 +0800 this is my 3rd commit commit 72fa1768fe5db08323394fe1f4a3fb8d71b7c712 Author: Zhao Fengyi Date: Tue Aug 23 20:10:09 2016 +0800 this is my 2nd commit commit 87ee65f7ff23afacbbe98c62965b243557e3a3e0 Author: Zhao Fengyi Date: Tue Aug 23 20:09:55 2016 +0800 this is my 1st commit 第三种办法（防患于未然，推荐）： ``` 为某个问题修改了一些文件 git commit -am \"blabla\" 为同样的问题又做了些修改 git commit -a --amend ---------- 找不同版本的区别 -- **常用场景**： 这个bug上个版本还没有，这个版本怎么就出现了呢？我得看看上个版本和这个版本之间都改了什么。 **解决办法**： - 粗糙版命令（适用于版本之间提交不多，git log .. -- 具体执行过程： src/main/java/com/xxx/yyy/ui/activity$ git log origin/v7.7..origin/v7.8 -- . commit aaaaaaaaaaaaaaaaaaaaaaaaaaaa Author: Y y@q.com Date: Tue Aug 23 18:12:33 2016 +0800 [需求开发]...... Change-Id: ...... commit bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb Author: l l@q.com Date: Tue Aug 23 15:26:21 2016 +0800 【bug fixed】...... commit cccccccccccccccccccccccccccccccccccccc Author: G g@q.com Date: Tue Aug 23 16:32:20 2016 +0800 需求-从第三方跳入...... Change-Id: ...... commit ddddddddddddddddddddddddddddddddddd Author: S s@q.com Date: Tue Aug 23 10:12:26 2016 +0800 [功能优化]去掉无用的xxx.java Change-Id: ...... 缺点是太多了，排版不紧凑，找个信息要半天。 - 精致版命令（紧凑，不费眼） git log .. --color --graph --pretty=format:'%Cred%h%Creset -%s %Cgreen(%cr) %C(bold blue)%Creset' -- 具体执行过程： src/main/java/com/xxx/yyy/ui/activity$ git log origin/v7.7..origin/v7.8 --color --graph --pretty=format:'%Cred%h%Creset -%s %Cgreen(%cr) %C(bold blue)%Creset' -- . a30af7c -[需求开发] ... (16 hours ago) cacb3f5 -【bug fixed】... (18 hours ago) b332d79 -需求-从第三方跳入... (18 hours ago) 0385105 -[功能优化] 去掉无用的 xxx.java (18 hours ago) ``` 这锅该谁背 常用场景： 找到了，就是这行代码改出来的问题，看看谁改的。 解决办法： git blame -L Android Studio有提供同样的操作： 高级一点的需求： git blame 只能看到谁加了这行，如果知道有些代码被删了，想看看谁删了怎么办呢？ 解决办法： git log -p -- 在打印里搜索被删除的行。 具体执行过程： src/main/java/com/xxx/yyy/ui/view/message$ git log -p -- LLLView.java 搜索 xxxManager\\.getyyy\\(\\)\\.play 方便的配置 作为一个熟悉git的人，我平时提交代码只需要1行命令就搞定了 git f && git rh && git rbm && git sa && git pm 要想操作这么便捷，做一些前期配置就可以一劳永逸了。 缩写alias git 这么多命令，敲起来又长又麻烦，一不小心敲错了就更烦了。 打开 ~/.gitconfig， 把下面的缩写添加进去 [alias] co = checkout cp = cherry-pick br = branch st = status l1 = log -1 pm = push origin HEAD:refs/for/master ap = apply cm = commit rbm = rebase origin/master f = fetch origin rh = reset --hard sa = stash apply --0 各种平台换行符不一致，git提交时统一转换： git config --global core.autocrlf true git config --global core.autocrlf true 暂存不用提交的修改 比如gradle project sync耗时太久，我改成用本地的服务器： distributionUrl=http\\://10.x.y.z:8080/download/gradle-2.12-all.zip 这个修改又不需要提交，只是本地开发时需要。 我们一般把不需要提交的修改用git stash暂存在本地； 需要提交的修改git commit提交到本地。 这样要提交的修改和不需要提交的修改就分开了，不会出现每次提交代码要自己再分离一次。 配置好了，git commit了需要提交的代码后，可以一行命令搞定推送到gerrit了。 git f && git rh && git rbm && git sa && git pm 命令 详细说明 git f git fetch origin 从git服务器获取最新代码状态 git rh git reset --hard 清空本地不需要提交的代码 git rbm git rebase origin/master 把自己的commit合并进master git sa git stash apply --0 恢复暂存的修改 git pm git push origin HEAD:refs/for/master 推到gerrit 然后继续开发下一个commit吧～ 其他 有时候会遇到一些棘手的问题。 比如：之前git commit了一个提交，然后做了一堆git checkout或者别的操作导致找不到这个commit了。 vi .git/logs/HEAD 或者 git reflog 都可以查看你的操作历史。曾经从哪里checkout到哪里，commit了什么，rebase到哪里了...都一目了然。 比如：之前解决了一次冲突，然后发现不应该这么解决，想换种办法解决。 但是git会自动记住你之前的解决办法，自动帮你解决了，你根本没有插手的机会。 rm -rf .git/rr-cache/* 让git忘记我之前的解决办法，这样就给了我插手的机会，重新解决一次。 暂时就写这么多啦，以后有需要再补充~ 欢迎指导和提意见 Written with StackEdit. "},"Others/fangjia.html":{"url":"Others/fangjia.html","title":"Fangjia","keywords":"","body":"首付情况 以总价350万的房子举例： 房价做低到309万，因为超过310万就不算普通住宅，要交增值税，不划算，所以一般房价都做到309万； 需要我们出的钱： 350-309=41万的差价 35%房价的首付=109万 1%房价的个税（除非满五唯一可以免了）=3.5万 1%房价的契税=3.5万 1.5%房价中介费=5万 总计162万 贷款情况 公积金贷款50万，商贷150万； 商贷的新政策利率不能低于4.85%； 公积金不能提取出来当做首付； 公积金只能有两种方式使用： 第一年选择年冲，把现有的15万公积金全部还掉，这样公积金贷款=50-15=35万，按照贷了35万来算利息；选择年冲这一年都不能使用公积金，这一年里面单位帮你交的公积金都只能存着，不能还贷，第二年再去办理年冲改月冲，才能每个月用单位交的公积金还贷；这种好处是利息少点，坏处是压力大，第一年要自己还； 一开始就选择月冲，这样商贷和公积金贷款放在一起计算每个月要还多少钱，先从公积金账户里面扣，假设每个月需要还1.5万，这样公积金账户里面的15万可以还10个月，这10个月不需要自己还，公积金账户里面的钱扣光了之后，需要你每个月自己还；这种好处是压力小点，坏处是利息稍微高点 "},"Others/gradle.html":{"url":"Others/gradle.html","title":"Gradle","keywords":"","body":"加log: logger.error(\"test \" + names) 看log: ./gradlew --info --debug "}}